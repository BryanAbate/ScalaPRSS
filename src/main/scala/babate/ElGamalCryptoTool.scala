package main.scala.babate

import org.abstractj.kalium.crypto.Random
import org.abstractj.kalium.crypto.SecretBox

/**
 * This class is meant to be used as a tool for encryption and decryption using threshold ElGamal encryption
 *
 * @param t the threshold
 *
 * @param n the total number of participants
 */
class ElGamalCryptoTool(t: Int, n: Int) {

  val tool = new SchnorrTool(t, n)
  val random = new Random()

  val secretKeySize = 32; //Hard coded because impossible to access them, refers to https://github.com/abstractj/kalium/blob/master/src/main/java/org/abstractj/kalium/NaCl.java
  val nonceSize = 24; //Same as above

  /**
   * Encrypt a message m and return it as an array of bytes
   *
   * @param m The message (an array of bytes) to encrypt
   *
   * @param Y The public key
   *
   * @param participantShares The shares generated by the PRSS
   *
   * @return The encrypted array of byte
   */
  def encrypt(m: Array[Byte], Y: GroupElement, participantShares: Map[Int, FieldElement]): (GroupElement, GroupElement, Array[Byte], Array[Byte]) = {

    require(participantShares.size >= t, "Not enough shares to compute Y")
    val shares = if (participantShares.size > t) participantShares.take(t) else participantShares

    val r = new FieldElement(random.randomBytes(tool.nBits / 8).foldLeft(0: BigInt) { case (acc, b) => (acc << 8) | (b & 0xFF) })
    val s = new FieldElement(random.randomBytes(tool.nBits / 8).foldLeft(0: BigInt) { case (acc, b) => (acc << 8) | (b & 0xFF) })

    val K = s * GroupElement.g
    val k = tool.hash.sha256(K.value.toByteArray)
    val A = r * GroupElement.g
    val B = (r * Y) + K

    val box = new SecretBox(k.take(secretKeySize))
    val nonce = random.randomBytes(nonceSize)
    val C = box.encrypt(nonce, m)

    (A, B, C, nonce)
  }

  /**
   * Encrypt a message m and return it as a string
   *
   * @param m The message (a string) to encrypt
   *
   * @param Y The public key
   *
   * @param participantShares The shares generated by the PRSS
   *
   * @param encoding The encoding used for the string (default UTF-8)
   *
   * @return The encrypted array of byte
   */
  def encrypt(m: String, Y: GroupElement, participantShares: Map[Int, FieldElement], encoding: String = "UTF-8"): (GroupElement, GroupElement, Array[Byte], Array[Byte]) = {
    encrypt(m.getBytes(encoding), Y, participantShares)
  }

  /**
   * Decrypt a cipher C and return it as an array of bytes
   *
   * @param A The first parameter returned by the encryption
   *
   * @param B The second parameter returned by the encryption
   *
   * @param C The third parameter returned by the encryption
   *
   * @param nonce The nonce returned by the encryption
   *
   * @param participantShares The shares generated by the PRSS
   *
   * @return The message decrypte as an array of bytes
   */
  def decryptAsByteArray(A: GroupElement, B: GroupElement, C: Array[Byte], nonce: Array[Byte], participantShares: Map[Int, FieldElement]) = {

    require(participantShares.size >= t, "Not enough shares to compute Y")
    val shares = if (participantShares.size > t) participantShares.take(t) else participantShares

    val ci = shares.map {
      case (i, _) =>
        i -> shares.filter(_._1 != i).map { k => (new FieldElement(k._1) / (new FieldElement(k._1) - new FieldElement(i))) }.foldLeft(new FieldElement(1)) { case (acc, v) => acc * v }
    }
    val Di = shares.map { case (i, xi) => i -> xi * A }
    val D = Di.map { case (i, iD) => ci(i) * iD }.foldLeft(new GroupElement(1)) { case (acc, v) => acc + v }
    val K = B - D
    val k = tool.hash.sha256(K.value.toByteArray)
    val box = new SecretBox(k.take(secretKeySize))
    box.decrypt(nonce, C)
  }

  /**
   * Decrypt a cipher C and return it as a String
   *
   * @param A The first parameter returned by the encryption
   *
   * @param B The second parameter returned by the encryption
   *
   * @param C The third parameter returned by the encryption
   *
   * @param nonce The nonce returned by the encryption
   *
   * @param participantShares The shares generated by the PRSS
   *
   * @param encoding The encoding used for the string (default UTF-8)
   *
   * @return The message decrypted as an array of bytes
   */
  def decryptAsString(A: GroupElement, B: GroupElement, C: Array[Byte], nonce: Array[Byte], participantShares: Map[Int, FieldElement], encoding: String = "UTF-8") = {
    new String(decryptAsByteArray(A, B, C, nonce, participantShares), encoding)
  }
}